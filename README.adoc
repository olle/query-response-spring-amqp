= Query/Response for Spring® AMQP

image:https://github.com/olle/spring-query-response-amqp/workflows/Java%20CI/badge.svg[title="Java CI", link="https://github.com/olle/query-response-spring-amqp/actions?query=workflow%3A%22Java+CI%22"] image:https://img.shields.io/lgtm/grade/java/g/olle/query-response-spring-amqp.svg?logo=lgtm&logoWidth=18[title="Language grade: Java", link="https://lgtm.com/projects/g/olle/query-response-spring-amqp/context:java"] image:https://badges.gitter.im/query-response-spring-amqp/community.svg[title="Join the chat!", link="https://gitter.im/query-response-spring-amqp/community"]

**WIP: Driving the initial version from this README, please feel free to
       provide feedback through issues.**

Build safer and more resilient distributed services. Get the benefits of an
_always async_ approach to data exchange. Ensure decoupling of components. Be
better prepared for system evolution. Create more scalable solutions. Change the
way you think and design, by using Query/Response for Spring AMQP.

== Quickstart

The Query/Response library can easily be added to any Spring Boot® project, as
a single dependency.

```xml
  <dependency>
    <!-- From Jitpack-repo -->
    <groupId>com.github.olle</groupId>
    <artifactId>query-response-spring-amqp</artifactId>
    <version>${SOME-TAG}</version>
  </dependency>
```

_At the current time we recommend using https://jitpack.io[Jitpack] to resolve
the dependency. Query/Response will however be published to the Sonatype OSS 
repository and Maven Central in the future._

=== `@EnableQueryResponse`

:QueryResponseConfiguration: link:./src/main/java/com/studiomediatech/queryresponse/QueryResponseConfiguration.java

To initialize the Query/Response library resources, and load the
{QueryResponseConfiguration}[`QueryResponseConfiguration`] class, the
`@EnableQueryResponse` annotation can simply be added to any Spring Boot 
application starter.

```java
@SpringBootApplication
@EnableQueryResponse
public class App {
  ...
}
```

The configuration will try to connect to an AMQP message broker, using the
common configurations for Spring AMQP. The default setup will try to connect
to a local broker with the username and password `guest/guest`.

_Please see the provided `examples/` for a simple setup with 
https://www.rabbitmq.com[RabbitMQ] as a docker container, to get you started._

== Queries

The fluid Query/Response API makes it easy for developers to understand and
decide on a strategy for service integration. Timeouts are _first-class
citizens_ in the API and protect against surprises.

```java
  var authors = queryBuilder.queryFor("authors", String.class)
                  .waitingFor(800)
                  .orEmpty();
```


== Responses

To create responding services we provide a really effective and expressive
fluid-API. Developers benefit from the declarative style, and won't have to
write any boilerplate code. It is easy to understand, work with and explore.

Very simple scenarios can quickly be created, for tests or proof of concept
work.

```java
  responseBuilder.respondTo("authors", String.class)
      .withAll()
      .from("William Gibson", "Isaac Asimov", "J.R.R. Tolkien");
```

== AMQP Resources & Formats

:AMQP: https://www.rabbitmq.com/protocol.html

The declared {AMQP}[AMQP] broker resources are very limited. Only the 
`query-response` topic-exchange is created. All active Query/Response services
will automatically declare the required exchange, with the following parameters:

```
  name: query-response
  type: topic
  auto-delete: true
```

The Query/Response library defines a small set of properties and data-formats,
which are used in the AMQP messages - a mini-protocol:

=== Query messages

Query messages are very simple in structure and form. The common
`query-response` exchanged is published to, and the message `routing-key` will
carry the specific `query-term` that is requested. The `reply-to` header
property is set to the queue name of a generated `query-response-queue`,
specific to the published query.

Both query and response messages use the `application/json` content-type. There
is no further content in the body, just an empty JSON object `{}`, as a
placeholder.

```
  exchange: query-response
  routing-key: ${query-term}
  reply-to: ${query-response-queue}
  content-type: application/json
  body:
  {}
```

=== Response messages

Published responses also use a common format. They are published to the empty
(default) exchange, with the `query-response-queue` from the `reply-to`
property of a consumed query as the `routing-key`. This will cause a direct
routing of responses back to the declared response-queue.

The response body payload JSON structure always wraps the `elements` collection
containing the actual response data in an _envelope object_.

```
  exchange: (default)
  routing-key: ${query-response-queue}
  content-type: application/json
  body:
  {
    elements: [...]
  }
```

The current properties of Query/Response messages are simple but provide
room for extensions in future versions.

Happy hacking!

---

Spring and Spring Boot are trademarks of Pivotal Software, Inc. in the U.S. and
other countries.

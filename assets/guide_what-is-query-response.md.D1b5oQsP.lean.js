import{_ as s,c as a,a2 as t,o}from"./chunks/framework.DYGJpL-T.js";const u=JSON.parse('{"title":"What is Query/Response?","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"guide/what-is-query-response.md","filePath":"guide/what-is-query-response.md","lastUpdated":1748509311000}'),n={name:"guide/what-is-query-response.md"};function i(r,e,l,h,p,c){return o(),a("div",null,e[0]||(e[0]=[t(`<h1 id="what-is-query-response" tabindex="-1">What is Query/Response? <a class="header-anchor" href="#what-is-query-response" aria-label="Permalink to &quot;What is Query/Response?&quot;">​</a></h1><p>Query/Response is an asynchronous non-blocking messaging pattern for building highly decoupled evolving service architectures.</p><h2 id="a-simple-example" tabindex="-1">A simple example <a class="header-anchor" href="#a-simple-example" aria-label="Permalink to &quot;A simple example&quot;">​</a></h2><p>Let&#39;s learn about the Query/Response pattern by walking through a small fictional example (no pun intended). The technical context is <em>messaging</em> and hints at some type of broker-based setup - in theory though, any asynchronous communication could be used. The examples are only pseudo-code and plain-text data, to keep things simple.</p><h3 id="any-good-sci-fi-books-out-there" tabindex="-1">Any good sci-fi books out there? <a class="header-anchor" href="#any-good-sci-fi-books-out-there" aria-label="Permalink to &quot;Any good sci-fi books out there?&quot;">​</a></h3><p>Let&#39;s publish a query.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>query: books.sci-fi</span></span>
<span class="line"><span>reply-to: library/books.sci-fi#42</span></span></code></pre></div><p>The structure above captures all the basic components that a query should communicate. The term <code>books.sci-fi</code> expresses the published <em>need</em>, and we can easily understand that it&#39;s a <em>request</em> for science fiction books.</p><p><em>The dot-notation is not at all required, the query can use any syntax that fits the platform or programming language.</em></p><p>The query has an address where responses should be sent back to: <code>library/books.sci-fi#42</code>. This is really important, not only in order to receive responses, but also to avoid coupling the sender to the query. We don&#39;t need to state who&#39;s publishing the query. The <code>reply-to</code> is just an address, a location or <em>mailbox</em> that can be used for replies.</p><p>The address is only for this particular query, and it is made to be unique. In this example <code>library/books.sci-fi#42</code> describes a topic <code>library</code>, and then the unique mailbox or queue for the query with a hash-code <code>books.sci-fi#42</code>.</p><h3 id="the-current-top-3-books" tabindex="-1">The current top-3 books <a class="header-anchor" href="#the-current-top-3-books" aria-label="Permalink to &quot;The current top-3 books&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>response: library/books.sci-fi#42</span></span>
<span class="line"><span>body:</span></span>
<span class="line"><span>    &quot;Neuromancer&quot;</span></span>
<span class="line"><span>    &quot;Snow Crash&quot;</span></span>
<span class="line"><span>    &quot;I, Robot&quot;</span></span></code></pre></div><p>We&#39;re in luck. We got a response! The information above represents a response to the query we published. It&#39;s sent to the address from the query, and carries a body or payload of information which may be of interest to us.</p><p>The response does not have to say who it&#39;s from. This allows us to think about exchange of information, without the notion of: <em>&quot;A sends a request to B, which responds to A&quot;</em>. We are making sure that the services are decoupled from each other, by letting the response be an <em>optional</em> message, sent to the <em>address</em> instead of a reply to the <em>sender</em>. More about this later.</p><h3 id="the-asimov-collection" tabindex="-1">The Asimov collection <a class="header-anchor" href="#the-asimov-collection" aria-label="Permalink to &quot;The Asimov collection&quot;">​</a></h3><p>Since our query was published as a notification, we&#39;re not bound to a single reply. We can keep on consuming any number of responses that are sent to the address we published.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>response: library/books.sci-fi#42</span></span>
<span class="line"><span>body:</span></span>
<span class="line"><span>    &quot;I, Robot&quot;</span></span>
<span class="line"><span>    &quot;The Gods Themselves&quot;</span></span>
<span class="line"><span>    &quot;Pebble in the Sky&quot;</span></span></code></pre></div><p>In this response we received a list of book titles which all have the same author. The previous was a list with popular books. This reply even has one entry which was already in the first response we received.</p><p>This is of course not a problem, and it shows us a couple of important things. Responses may come from different sources and contexts. This means that the consumer of a response will have to assert the value or <em>usefulness</em> of the received information, and decide how to handle it.</p><div class="warning custom-block"><p class="custom-block-title">Important</p><p>The structure of a response should of course conform to some common, agreed upon, format or data-shape. More on this later.</p></div><p>Considering all this, we need to remember <a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noreferrer">Postel&#39;s Law</a>. Information should be liberally handled (interpreted), but publishing should be done more conservatively. As a consumer of responses we just can&#39;t have a guarantee that the information received is valid, well formed or not malicious. We have to consume, convert and validate with great care. The decoupling in the Query/Response patter has a price, and this is one part of it.</p><div class="danger custom-block"><p class="custom-block-title">Consideration</p><p>But is a published REST-endpoint, for POST requests, that much better? I would argue that we still have the same requirements. To be able to handle requests liberally, we have to convert and validate, with great care. But we are coupling the client and server to each other and, what is perhaps even worse, we&#39;re actually allowing the client to control the writing of information inside the server. We have at least surrendered to that model of thinking. The POST is a write operation!</p></div><p><em>To really think and reason about who&#39;s controlling the write operation, can be a very powerful concept in my view. And arguably, the further away we can push this authority from the actual, internal act of writing, the less we need to think about the complexity of both collaborators at once. This is of course the essence of messaging. We could still achieve this with the REST endpoint, but I would say that it is a lot harder to avoid thinking about the effect of the returned response from the POST request. Even if it is empty. We are caught in a lock-step or imperative model.</em></p><h3 id="no-book-lovers-out-there" tabindex="-1">No book lovers out there? <a class="header-anchor" href="#no-book-lovers-out-there" aria-label="Permalink to &quot;No book lovers out there?&quot;">​</a></h3><p>Let&#39;s rewind the scenario a bit. Let&#39;s say we&#39;ve just published the query, but no responses arrive. What should we do?</p><p>This is not a flaw in the design, but a specific part of the Query/Response pattern. It is always up to the consumer of responses (the one that sent the query), to decide <em>how long</em> it will continue to read, or wait for any to arrive at all. The pattern does not force this or make any promises.</p><p>There might be responses. There may be none, a single one or a huge amount. This is by design, and it forces us to think about important questions, early in development. Fallback values, proper defaults, circuit-breakers and how to deal with a flood of responses.</p><div class="warning custom-block"><p class="custom-block-title">Important</p><p>The most commonly asked question, by developers new to the Query/Response pattern, is: &quot;But what if there are no responses, what do I show the user?&quot;. Exactly! Plan for that. This is something that should be considered early in design and development. There might very well be a response, eventually, but how long do you let the user wait for a result?</p></div><h3 id="reprise-surprise" tabindex="-1">Reprise, surprise <a class="header-anchor" href="#reprise-surprise" aria-label="Permalink to &quot;Reprise, surprise&quot;">​</a></h3><p>Back to our original scenario. We&#39;ve received both the top-3, as well as a collection of Asimov books. And we&#39;re still open for more responses to the published address.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>response: library/books.sci-fi#42</span></span>
<span class="line"><span>body:</span></span>
<span class="line"><span>    &quot;Neuromancer&quot;</span></span>
<span class="line"><span>    &quot;Snow Crash&quot;</span></span>
<span class="line"><span>    &quot;I, Robot&quot;</span></span></code></pre></div><p>Hey, what&#39;s this! We now received the same response and body payload, as before. This is still not a problem, and it&#39;s not a flaw in the pattern. It is not possible to avoid multiple responses, even from the same publisher. As a consumer, we have to be ready to handle it. There is nothing wrong with this response at all.</p><p><em>The consumer must handle this, and can&#39;t keep the entries in a simple list. If we did, it would contain several duplicate entries. It would be enough to use a set instead, so any duplicate entries would only be kept once.</em></p><h3 id="so-what-s-in-the-library" tabindex="-1">So, what&#39;s in the library? <a class="header-anchor" href="#so-what-s-in-the-library" aria-label="Permalink to &quot;So, what&#39;s in the library?&quot;">​</a></h3><p>Let&#39;s see what we have.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>query: library.sci-fi</span></span>
<span class="line"><span>reply-to: bookshelf/library.sci-fi#1337</span></span></code></pre></div><p>A new query is published and we understand the <code>query</code> term to mean that there&#39;s an <em>interest</em> in knowing what books are in the library. A successful scenario could arrive at the following response being consumed.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>response: bookshelf/library.sci-fi#1337</span></span>
<span class="line"><span>body:</span></span>
<span class="line"><span>    &quot;Neuromancer&quot;</span></span>
<span class="line"><span>    &quot;Snow Crash&quot;</span></span>
<span class="line"><span>    &quot;I, Robot&quot;</span></span>
<span class="line"><span>    &quot;The Gods Themselves&quot;</span></span>
<span class="line"><span>    &quot;Pebble in the Sky&quot;</span></span></code></pre></div><p>Just as expected.</p><h3 id="inversion-of-flow" tabindex="-1">Inversion of flow <a class="header-anchor" href="#inversion-of-flow" aria-label="Permalink to &quot;Inversion of flow&quot;">​</a></h3><p>What we&#39;ve seen in this example scenario is actually an inversion of what could have been implemented as a tightly coupled, chained set of synchronous service calls:</p><blockquote><p>A user whishes to view a list of science fiction books through the <code>Bookshelf</code> service, which needs to call the <code>Library</code> for the list. The <code>Library</code> service aggregates all sci-fi books by calls to 2 configured services: <code>Top-3</code> and <code>Authors</code>. Only after both service calls return, can the <code>Library</code> respond to the <code>Bookshelf</code> and the user is presented with a list of sci-fi books.</p></blockquote><p>In this type of system, not only are the calls aggregated in the total time, effectively forcing the user to wait until all calls return, but also to the availability of each service. This accumulates at the point of the user, making it highly probable that viewing the list of books will fail.</p><p><em>There are many ways to work towards better and more resilient solutions, also in the synchronous solution. I&#39;m not trying to say that it is the wrong model. The point I&#39;m trying to make, is the very different way of thinking that the Query/Response pattern forces us into from the start. Availability, fallbacks, resilience and strict timeouts are called out as key-concepts.</em></p><p><em>I hope this illustrates what&#39;s possible using this approach and that I&#39;ve sparked at least som interest in the Query/Response pattern. Later I will extend on some of the features and caveats.</em></p>`,46)]))}const b=s(n,[["render",i]]);export{u as __pageData,b as default};

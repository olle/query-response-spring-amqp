import{B as a}from"./chunks/attributes.BUGtF-W3.js";import{c as e,j as s,t as n,a as i,a3 as t,o as h}from"./chunks/framework.BLMDJhiA.js";const l=s("h1",{id:"getting-started",tabindex:"-1"},[i("Getting Started "),s("a",{class:"header-anchor",href:"#getting-started","aria-label":'Permalink to "Getting Started"'},"​")],-1),p=s("h2",{id:"system-requirements",tabindex:"-1"},[i("System Requirements "),s("a",{class:"header-anchor",href:"#system-requirements","aria-label":'Permalink to "System Requirements"'},"​")],-1),k=s("strong",null,"Spring Boot 2.x",-1),r=s("strong",null,"Java 11",-1),o=s("strong",null,"Java 11",-1),d=s("strong",null,"Spring Boot 3.0.3",-1),E=t("",2),g=s("code",null,"QueryResponseConfiguration",-1),c=s("code",null,"@EnableQueryResponse",-1),y=t("",4),F=s("a",{href:"https://www.rabbitmq.com",target:"_blank",rel:"noreferrer"},"https://www.rabbitmq.com",-1),u=s("code",null,"5672",-1),b=t("",3),m=t("",1),C=s("a",{href:"http://localhost:15672",target:"_blank",rel:"noreferrer"},"http://localhost:15672",-1),_=s("h2",{id:"queries",tabindex:"-1"},[i("Queries "),s("a",{class:"header-anchor",href:"#queries","aria-label":'Permalink to "Queries"'},"​")],-1),B=s("p",null,[i("Publishing "),s("strong",null,"queries"),i(" is a way for your application to ask for information that it may need in order to accomplish tasks. Queries express a "),s("em",null,"need"),i(", and are not addressed to any specific service or component.")],-1),A=s("code",null,"QueryBuilder",-1),v=t("",10),D=s("em",null,"micro",-1),f=s("strong",null,"responses",-1),q=s("code",null,"ResponseBuilder",-1),T=t("",8),I=JSON.parse('{"title":"Getting Started","description":"","frontmatter":{},"headers":[],"relativePath":"guide/getting-started.md","filePath":"guide/getting-started.md","lastUpdated":1720849524000}'),w={name:"guide/getting-started.md"},Q=Object.assign(w,{setup(S){return(P,R)=>(h(),e("div",null,[l,s("p",null,n(a)+" makes it really easy to extend Spring Boot stand-alone, production-grade applications, that are using Spring AMQP. We have taken a working pattern for building highly decoupled evolving service architectures, and wrapped it in a developer friendly library.",1),p,s("p",null,[i(n(a)+" requires at least ",1),k,i(" and "),r,i(", and should work for later releases too. We are building and running it successfully with "),o,i(" and the "),d,i(" version.")]),E,s("p",null,[i("Enabling "+n(a)+" is done by loading the ",1),g,i(" class. The most simple way to do this, is by annotating your Spring Boot application with the "),c,i(" annotation.")]),y,s("p",null,[i("Before you can run your application you need to make sure there is an AMQP broker available. By default "+n(a)+" tries to connect to a ",1),F,i("[RabbitMQ], running locally on port "),u,i(".")]),b,s("p",null,"Now running your application, will enable "+n(a)+", connect to the broker and create all the resources necessary on the broker.",1),m,s("p",null,[i("Now is a good time to use the RabbitMQ Management UI, available at "),C,i(", to inspect the exchange, queues and bindings created by "+n(a)+" by default.",1)]),_,B,s("p",null,[i(n(a)+" makes it really really easy, to create and publish a query using the ",1),A,i(".")]),v,s("p",null,[i("Building services, medium, large or "),D,i(" (who cares), that publish "),f,i(" to queries is also really easy with "+n(a)+", using the ",1),q,i(".")]),T]))}});export{I as __pageData,Q as default};

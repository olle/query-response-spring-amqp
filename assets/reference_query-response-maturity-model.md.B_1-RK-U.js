import{_ as e,c as t,o as a,a3 as o}from"./chunks/framework.BLMDJhiA.js";const y=JSON.parse('{"title":"Query/Response Maturity Model","description":"","frontmatter":{},"headers":[],"relativePath":"reference/query-response-maturity-model.md","filePath":"reference/query-response-maturity-model.md","lastUpdated":1720465254000}'),r={name:"reference/query-response-maturity-model.md"},n=o('<h1 id="query-response-maturity-model" tabindex="-1">Query/Response Maturity Model <a class="header-anchor" href="#query-response-maturity-model" aria-label="Permalink to &quot;Query/Response Maturity Model&quot;">​</a></h1><p>Just like with the <a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="noreferrer">Richardson Maturity Model</a>, I&#39;ve identified an evolution of maturity around the acceptance, use and implementation of Query/Response. It describes the benefits, opportunities and also complexities, pretty well.</p><h2 id="level-0-purgatory" tabindex="-1">Level 0 - Purgatory <a class="header-anchor" href="#level-0-purgatory" aria-label="Permalink to &quot;Level 0 - Purgatory&quot;">​</a></h2><p>All communication and exchange is bound to fixed, configured, service end- points. Synchronous blocking calls exchange information based on formats declared in project Wiki-pages or Word-documents. Most solutions are stateless, with I/O bound performance. Changes typically require system wide, synchronized, upgrades. This lead to development dropping in velocity, as each module or team will find it hard or impossible to act independently of each other.</p><h2 id="level-1" tabindex="-1">Level 1 <a class="header-anchor" href="#level-1" aria-label="Permalink to &quot;Level 1&quot;">​</a></h2><p>Using the Query/Response pattern for the first time often leads to healthy temporal decoupling pretty quick. But with a lot of code still written with a synchronous model in mind, the data exchange tend to look a bit like <em>sync</em>. Solutions move towards being stateful, but loosen their I/O-bound performance characteristics. It&#39;s hard for developer to think about queries and responses not coming from known components. Already at this level teams and modules gain a lot in the capability to move independently. Releases and deployment is practically not a tangle any more, although the view on evolutionary data-structures or protocols for data, may lag behind and still be Wiki/Document-based.</p><h2 id="level-2" tabindex="-1">Level 2 <a class="header-anchor" href="#level-2" aria-label="Permalink to &quot;Level 2&quot;">​</a></h2><p>At this level a deeper insight into the value of a proper data-structure or protocol for payload, which can evolve as required, is often gained. With this comes the extended benefit of seamless upgrades and service evolution. Developers get to experience how responsibilities can move without breaking or changing any integration code - response publishers can change owners and location.</p><h2 id="level-3" tabindex="-1">Level 3 <a class="header-anchor" href="#level-3" aria-label="Permalink to &quot;Level 3&quot;">​</a></h2><p>More and more ideas around reactivity and flexibility begin to take form. Events can immediately trigger queries which may enrich a local context based on current needs. This moves the design and use beyond a system using sync, and durable persistent state, to a more ephemeral and <em>living</em> model. The data structure of payloads tend to be less bound to strict <em>types</em> and more malleable <em>data shapes</em>.</p><h2 id="level-4-and-beyond" tabindex="-1">Level 4 and beyond... <a class="header-anchor" href="#level-4-and-beyond" aria-label="Permalink to &quot;Level 4 and beyond...&quot;">​</a></h2><p>Information exchange using the Query/Response pattern allows for almost limitless evolution of services, or components, no longer bound to versions or availability. The structure of any data is also very dynamic, information can be partial, enriched, or come in different sets, from different publishers. No schema is required at this level, but <em>data shapes</em> are used, which can be embraced by all collaborators in the architecture. Queries are sent and responses consumed, sometimes within deliberate timeouts; take-until semantics. This way modules can provide, and fulfill, explicit SLAs if required.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>This is of course not supposed to be taken too seriously, but the maturity levels describes a journey, from a strict and stale model, into one where evolution and change is quite normal.</p></div>',13),i=[n];function s(l,d,c,u,h,m){return a(),t("div",null,i)}const f=e(r,[["render",s]]);export{y as __pageData,f as default};

import{B as i}from"./chunks/attributes.BUGtF-W3.js";import{c as n,j as e,a as s,t,a3 as a,o as l}from"./chunks/framework.Bsyxd66g.js";const h=e("h1",{id:"developers-reference",tabindex:"-1"},[s("Developers Reference "),e("a",{class:"header-anchor",href:"#developers-reference","aria-label":'Permalink to "Developers Reference"'},"​")],-1),o=e("h2",{id:"overview",tabindex:"-1"},[s("Overview "),e("a",{class:"header-anchor",href:"#overview","aria-label":'Permalink to "Overview"'},"​")],-1),r=e("em",null,"streams",-1),d=e("em",null,"futures",-1),p=e("em",null,"promises",-1),k=e("em",null,"normal",-1),c=e("a",{href:"https://en.wikipedia.org/wiki/Distributed_computing",target:"_blank",rel:"noreferrer"},"distributed systems",-1),u=e("p",null,[s("In the next couple of sections we'll look closer at the "),e("code",null,"QueryBuilder"),s(" and the "),e("code",null,"ResponseBuilder"),s(" types. We'll discuss how to use them in detail, and try to explain the concepts behind them, and the intention of their implementation.")],-1),E=e("h2",{id:"querybuilder",tabindex:"-1"},[e("code",null,"QueryBuilder"),s(),e("a",{class:"header-anchor",href:"#querybuilder","aria-label":'Permalink to "`QueryBuilder`"'},"​")],-1),m=e("code",null,"QueryBuilder",-1),g=e("code",null,"@EnableQueryResponse",-1),y=a("",3),b=e("code",null,"String.class",-1),f=a("",25),F=a("",4),v=e("code",null,"ResponseBuilder",-1),C=a("",7),_={class:"info custom-block"},w=e("p",{class:"custom-block-title"},"Note",-1),B=e("code",null,"com.fasterxml.jackson.databind.ObjectMapper",-1),A=a("",21),P=JSON.parse('{"title":"Developers Reference","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"reference/developers-reference.md","filePath":"reference/developers-reference.md","lastUpdated":1720631212000}'),T={name:"reference/developers-reference.md"},R=Object.assign(T,{setup(q){return(D,x)=>(l(),n("div",null,[h,o,e("p",null,[s("The goal of "+t(i)+" is to provide developers with tools that are easy to use and understand. We believe that a procedural and imperative style of writing programs, or thinking about tasks in programs, is broadly understood and a very valuable model. With "+t(i)+" we try to support this, rather than introducing any new concepts for ",1),r,s(", "),d,s(" or "),p,s(".")]),e("p",null,[s("With "+t(i)+" developers should feel enabled to write code in a ",1),k,s(" way. However, it is our mission to raise awareness of things that are hard to consider, when building "),c,s(". The tools try to convey these considerations, by making them transparent and part of the API.")]),u,E,e("p",null,[s("The "),m,s(" class is a central point of entry, and provides a fluent builder-API, for publishing queries. It's provided as a bean, by enabling "+t(i)+", using the ",1),g,s(" annotation. It may be injected as a dependency to provide access from methods in any Spring component.")]),y,e("p",null,[s("The second argument is the expected type of any received response elements. It is not published with the query, but rather used to coerce or interpret any received responses. This means that regardless of the payload of any response, in this case "+t(i)+" will attempt to read the response elements as the declared type ",1),b,s(".")]),f,e("p",null,"It is possible to express constraints at the integration point, also when using "+t(i)+", throwing on an unfulfilled query, as an option to more lenient handling with defaults.",1),F,e("p",null,[s("Another entry-point into "+t(i)+" is the ",1),v,s(". It provides a fluid builder-API that allows users to create responding services or components.")]),C,e("div",_,[w,e("p",null,[s("The data mapper mentioned above, is in fact the "),B,s(" and "+t(i)+" currently uses JSON as the transport format. This means that type hints, JSON mapping configuration annotations or custom mappings will apply. However as data mapping on the consumer side is done by coercion, the published format must conform to some agreed upon standard, shape or protocol.",1)])]),A]))}});export{P as __pageData,R as default};

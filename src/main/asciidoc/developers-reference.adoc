= Developers Reference

include::attributes.adoc[]

== Overview

The goal of {qr-name} is to provide developers with tools that are easy to use
and understand. We believe that a procedural and imperative style of writing
programs, or thinking about tasks in programs, is broadly understood and
valuable model. With {qr-name} we try to support this, rather than introducing
any new concepts for _streams_, _futures_ or _promises_.

:DISTR: https://en.wikipedia.org/wiki/Distributed_computing

With {qr-name} developers should feel enabled to write code in a _normal_ way.
However, it is our mission to raise awareness of things that are hard to
consider, when building {DISTR}[distributed systems]. The tools try to convey
these considerations, by making them transparent and part of the API.

In the next couple of sections we'll look closer at the `QueryBuilder` and the
`ResponseBuilder` types. We'll discuss how to use them in detail, and try to
explain the concepts behind them, and the intention of their implementation.

== `QueryBuilder`

The `QueryBuilder` class is the central entry-point, and provides a fluent
builder-API, for publishing queries. It's provided as a bean, by enabling
{qr-name}, using the `@EnableQueryResponse` annotation. It may be injected
as a dependency to provide access from methods in any Spring component.

We recommend injecting it via the component constructor, and keeping it as a
private field. The `findAuthors()` method below, shows how to access the
`queryBuilder` field in order to publish a query.

Queries built and published using the `QueryBuilder.queryFor(..)` method.

[source,java]
----
include::{examples-src}/querying/src/main/java/examples/Authors.java[tags=authorsClass]
----

In the example above, the published query is defined by the string **term** 
`"authors"`. This is how the most basic contract of {qr-pfx} is defined. A any
string or text term may be published as a query.

The second argument is the expected type of any received response elements. It
is not published with the query, but rather used to coerce or interpret any
received responses. This means that regardless of the payload of any response 
{qr-name} will attempt to read the response elements as the type `String.class`.

TODO!

Defaults are suddenly top-of-mind for developers, and either the _empty case_
is good enough, or fallbacks can be provided.

```java
  var authors = queryBuilder.queryFor("authors", String.class)
                  .waitingFor(800)
                  .orDefaults(Authors.defaults());
```

Preserve resources specific to the current needs and protect your services,
by limiting the amount of data consumed.

```java
  var authors = queryBuilder.queryFor("authors", String.class)
                  .takingAtMost(10)
                  .waitingFor(800)
                  .orDefaults(Authors.defaults());
```

Express constraints and react accordingly, throwing on an unfulfilled query, as
an option to lenient handling with defaults.

```java
  var offers = queryBuilder.queryFor("offers/rental", Offer.class)
                  .takingAtLeast(10)
                  .takingAtMost(20)
                  .waitingFor(2, ChronoUnit.SECONDS)
                  .orThrow(TooFewOffersConstraintException::new);
```

Optional capabilities to handle exceptions and errors are built-in and very
easy to use.

```java
  var offers = queryBuilder.queryFor("offers/rental", NewOffer.class)
                  .takingAtLeast(3)
                  .waitingFor(400)
                  .onError(error -> LOG.error("Failure!", error))
                  .orThrow(TooFewOffersConstraintException::new);
```

== `ResponseBuilder`

TODO!

Batch responses provide developers with more options to tune and throttle a
system using Query/Response across many services.

```java
  responseBuilder.respondTo("offers/monday", Offer.class)
      .withBatchesOf(20)
      .from(offers.findAllOffersByDayOfWeek(Calendar.MONDAY));
```

Dynamic responses are easy to build, with an API that suits modern Java, using
lazy calls to suppliers of data.

```java
  responseBuilder.respondTo("users/current", Token.class)
      .withBatchesOf(128)
      .suppliedBy(userTokenService::findAllCurrentUserTokens);
```

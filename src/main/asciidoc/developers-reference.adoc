= Developers Reference

include::attributes.adoc[]

== Overview

The goal of {qr-name} is to provide developers with tools that are easy to use
and understand. We believe that a procedural and imperative style of writing
programs, or thinking about tasks in programs, is broadly understood and
valuable model. With {qr-name} we try to support this, rather than introducing
any new concepts for _streams_, _futures_ or _promises_.

:DISTR: https://en.wikipedia.org/wiki/Distributed_computing

With {qr-name} developers should feel enabled to write code in a _normal_ way.
However, it is our mission to raise awareness of things that are hard to
consider, when building {DISTR}[distributed systems]. The tools try to convey
these considerations, by making them transparent and part of the API.

In the next couple of sections we'll look closer at the `QueryBuilder` and the
`ResponseBuilder` types. We'll discuss how to use them in detail, and try to
explain the concepts behind them, and the intention of their implementation.

== `QueryBuilder`

The `QueryBuilder` class is a central point of entry, and provides a fluent
builder-API, for publishing queries. It's provided as a bean, by enabling
{qr-name}, using the `@EnableQueryResponse` annotation. It may be injected
as a dependency to provide access from methods in any Spring component.

We recommend injecting it via the component constructor, and keeping it as a
private field. The `findAuthors()` method below, shows how to access the
`queryBuilder` field in order to publish a query.

[source,java]
----
include::{examples-src}/querying/src/main/java/examples/Authors.java[tags=authorsClass]
----

In the example above, the published query is defined by the string **term** 
`"authors"`. This is how the most basic contract of {qr-pfx} is defined. Any
string or text term may be published as a query.

The second argument is the expected type of any received response elements. It
is not published with the query, but rather used to coerce or interpret any
received responses. This means that regardless of the payload of any response,
in this case {qr-name} will attempt to read the response elements as the
declared type `String.class`.

Queries are built and published using the `queryFor(..)` _initial_ method.
Any following call to one of the _terminal_ methods `orEmpty()`,
`orDefaults(..)` and `orThrows(..)` will build and execute the query, and block
on the calling thread.

Since the call above to `orEmpty()` blocks the thread, users have to specify
one or more query _conditionals_. In the example above, the call to
`waitingFor(..)` defines that the call will block for around 800 milliseconds.

Constructing queries with the `QueryBuilder` revolves around creating a
composition of _initial_, _conditional_, maybe an optional _informal_ and
exactly one _terminal_ method call. In the table below is a short review of the
different builder methods and their types.

[cols="1,1,3"]
.`QueryBuilder` fluid API method types
|===
| Method              | Type          | Description

| `queryFor(..)`      | _initial_     | Creates a new builder for a query
| `waitingFor(..)`    | _conditional_ | Specifies the waiting/blocking condition
| `takingAtMost(..)`  | _conditional_ | Sets a limit condition, a maximum
| `takingAtLeast(..)` | _conditional_ | Sets a limit condition, a minimum
| `orEmpty()`         | _terminal_    | Terminates with empty, after conditionals are evaluated
| `orDefaults(..)`    | _terminal_    | Terminates with some defaults, after conditionals are evaluated
| `orThrow(..)`       | _terminal_    | Terminates by throwing, after conditionals are evaluated
| `onError(..)`       | _informal_    | Allows for explicit logging etc.
|===

Let's take a closer look at each of the builder method types.

=== _Initial_ methods

At the moment there's only one _initial_ method and it's declared as:

```java
  public <T> ChainingQueryBuilder<T> queryFor(String term, Class<T> type)
```

So we can query for any `String` **term** and given the expected mapped or
coerced **type** as a `Class<T>`. The returned `ChainingQueryBuilder<T>`
provides the capabilities of the fluid API.

=== _Conditional_ methods

All _conditional_ properties can be composed together by the `QueryResponse`
builder API, to define whether a query is successful or not. If an executing
query is completed in a *successful* way, fulfilling the _conditionals_, it will
return and not consume any more responses.

* `waitingFor(..)` - defines a timeout _conditional_. The built query will
  evaluate as *successful* if _any_ responses were consumed after the
  (approximate) given time limit has elapsed. There are a few different methods
  declared, to specify the timeout:

** `waitingFor(long millis)`
** `waitingFor(long amount, TemporalUnit timeUnit)`
** `waitingFor(Duration duration)`

* `takingAtMost(int atMost)` - defines a limiting _conditional_ on the
  aggregated number of received elements. The built query evaluates to
  *successful*, and returns, when the given amount is reached.

* `takingAtLeast(int atLeast)` - defines a minimum _conditional_ on the number
  of received element. The built query evaluates to *successful*, only if at
  least the given number of elements can be consumed.

=== _Terminal_ methods

Only one _terminal_ method can be invoked on the builder, per query. It will
ensure that the query is built and executed. All _terminal_ methods are
declared to return `Collection<T>` where the type parameter `<T>` is given
in the _initial_ method `type` parameter.

* `orEmpty()` - defines the query to return an empty `Collection` in case the
  _conditionals_ do not evaluate to *successful*.

* `orDefaults(..)` - defines the query to return with some provided _defaults_
  in case the _conditionals_ do not evaluate to *successful*. There are a couple
  different methods declared for defaults:

** `orDefaults(Collection<T> defaults)` - set at _build-time_.

** `orDefaults(Supplier<Collection<T>> defaults)` - supplied at _run-time_.
  
* `orThrow(..)` - defines the query to throw an exception in case the
  _conditionals_ do not evaluate to *successful*.

=== _Informal_ methods

Currently there's only one _informal_ builder method, allowing for extended
logging or information capture, in case the query fails or an exception is
thrown.

```java
  public ChainingQueryBuilder<T> onError(Consumer<Throwable> handler)
```

TIP: Try to think more about how the `QueryBuilder` API covers the exceptional
     query-cases, as part of the composition of _conditionals_. If clients try
     to use _terminals_ that provide sensible defaults, it may not be necessary
     to build other types of complex recovery or retries.

=== `QueryBuilder` examples

Below are some examples of how the different `QueryBuilder` API methods can be
combined.

Using `takingAtMost(..)`, combined with `waitingFor(..)`, system resources may
be preserved and the client can be protected from consuming too much data.

```java
  return queryBuilder.queryFor("authors", String.class)
                  .takingAtMost(10)
                  .waitingFor(800)
                  .orDefaults(Authors.defaults());
```

It is possible to express constraints at the integration point, also when using
{qr-name}, throwing on an unfulfilled query, as an option to more lenient
handling with defaults.

```java
  return queryBuilder.queryFor("offers/rental", Offer.class)
                  .takingAtLeast(10)
                  .takingAtMost(20)
                  .waitingFor(2, ChronoUnit.SECONDS)
                  .orThrow(TooFewOffersConstraintException::new);
```

The _informal_ builder feature, allows for transparency into queries that may
have to be observed.

```java
  return queryBuilder.queryFor("offers/rental", NewOffer.class)
                  .takingAtLeast(3)
                  .waitingFor(400)
                  .onError(error -> LOG.error("Failure!", error))
                  .orThrow(TooFewOffersConstraintException::new);
```

== `ResponseBuilder`

TODO!

Batch responses provide developers with more options to tune and throttle a
system using Query/Response across many services.

```java
  responseBuilder.respondTo("offers/monday", Offer.class)
      .withBatchesOf(20)
      .from(offers.findAllOffersByDayOfWeek(Calendar.MONDAY));
```

Dynamic responses are easy to build, with an API that suits modern Java, using
lazy calls to suppliers of data.

```java
  responseBuilder.respondTo("users/current", Token.class)
      .withBatchesOf(128)
      .suppliedBy(userTokenService::findAllCurrentUserTokens);
```
